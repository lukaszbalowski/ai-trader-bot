<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Watcher Backtester</title>
  <style>
    :root {
      --bg: #07111c;
      --panel: rgba(10, 23, 37, 0.82);
      --panel-strong: rgba(14, 31, 48, 0.96);
      --line: rgba(142, 187, 214, 0.16);
      --text: #edf4fa;
      --muted: #8ea1b2;
      --accent: #5cc8a1;
      --accent-warm: #ffbc5c;
      --danger: #ff6f6f;
      --shadow: 0 24px 80px rgba(0, 0, 0, 0.28);
      --font-ui: "IBM Plex Sans", "Avenir Next", "Segoe UI", sans-serif;
      --font-display: "IBM Plex Mono", "Menlo", monospace;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--font-ui);
      color: var(--text);
      background:
        radial-gradient(circle at top left, rgba(92, 200, 161, 0.22), transparent 32%),
        radial-gradient(circle at top right, rgba(255, 188, 92, 0.18), transparent 28%),
        linear-gradient(160deg, #07111c 0%, #091827 48%, #041019 100%);
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      background-image: linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size: 28px 28px;
      opacity: 0.35;
    }

    .app {
      width: min(1580px, calc(100vw - 32px));
      margin: 24px auto 40px;
      display: grid;
      gap: 18px;
      animation: fadeIn 360ms ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hero,
    .panel {
      border: 1px solid var(--line);
      background: var(--panel);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      border-radius: 20px;
    }

    .hero { padding: 22px; display: grid; gap: 18px; }
    .panel { padding: 18px; }

    .hero-top,
    .panel-head {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 14px;
      flex-wrap: wrap;
    }

    .eyebrow {
      margin: 0 0 6px;
      color: var(--accent);
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
    }

    h1 {
      margin: 0;
      font-size: clamp(28px, 5vw, 44px);
      line-height: 1;
    }

    h2 {
      margin: 0 0 14px;
      font-size: 17px;
      letter-spacing: 0.03em;
    }

    .hero-meta,
    .actions,
    .pill-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .pill,
    .chip {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 8px 12px;
      font-size: 13px;
      color: var(--muted);
      background: rgba(255, 255, 255, 0.03);
    }

    .chip.active {
      color: var(--text);
      border-color: rgba(92, 200, 161, 0.35);
      background: rgba(92, 200, 161, 0.08);
    }

    .summary-grid,
    .layout,
    .control-grid {
      display: grid;
      gap: 18px;
    }

    .summary-grid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .summary-card,
    .metric-card,
    .progress-card,
    .combo-card,
    .result-card {
      padding: 16px 18px;
      border: 1px solid var(--line);
      border-radius: 16px;
      background: rgba(255, 255, 255, 0.025);
    }

    .summary-card .label,
    .metric-label,
    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    .summary-card .value,
    .metric-value {
      font-family: var(--font-display);
      font-size: clamp(20px, 4vw, 30px);
      margin-top: 8px;
    }

    .layout.primary {
      grid-template-columns: minmax(0, 1.15fr) minmax(320px, 0.85fr);
    }

    .layout.secondary {
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 1fr);
    }

    .stack,
    .combo-list,
    .result-list,
    .log-list,
    .checkbox-grid {
      display: grid;
      gap: 12px;
    }

    .control-grid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }

    .toggle-group {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    button,
    .link-button {
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 10px 14px;
      cursor: pointer;
      color: var(--text);
      background: rgba(255, 255, 255, 0.04);
      transition: transform 140ms ease, border-color 140ms ease, background 140ms ease;
      font-family: inherit;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    button:hover,
    .link-button:hover {
      transform: translateY(-1px);
      border-color: rgba(92, 200, 161, 0.35);
      background: rgba(92, 200, 161, 0.08);
    }

    button.primary {
      background: rgba(92, 200, 161, 0.12);
      border-color: rgba(92, 200, 161, 0.35);
    }

    button.attention {
      background: rgba(255, 188, 92, 0.16);
      border-color: rgba(255, 188, 92, 0.45);
      color: #fff3d6;
    }

    button.danger {
      background: rgba(255, 111, 111, 0.08);
      border-color: rgba(255, 111, 111, 0.32);
    }

    button:disabled {
      opacity: 0.45;
      cursor: default;
      transform: none;
    }

    .checkbox-item,
    details.combo-card {
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 14px;
      background: rgba(255, 255, 255, 0.025);
    }

    label.option {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      cursor: pointer;
    }

    input[type="checkbox"],
    input[type="radio"] {
      accent-color: var(--accent);
      margin-top: 2px;
    }

    .option-title {
      font-weight: 600;
      margin-bottom: 3px;
    }

    .option-sub {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
    }

    details summary {
      list-style: none;
      cursor: pointer;
    }

    details summary::-webkit-details-marker {
      display: none;
    }

    .combo-top {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
      flex-wrap: wrap;
    }

    .combo-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    .combo-kpis {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
    }

    .combo-body {
      margin-top: 14px;
      display: grid;
      gap: 14px;
    }

    details.result-card {
      padding: 0;
      overflow: hidden;
    }

    .result-summary {
      padding: 16px 18px;
    }

    .result-body {
      padding: 0 18px 18px;
      display: grid;
      gap: 14px;
      border-top: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.02);
    }

    .history-block,
    .preview-block {
      display: grid;
      gap: 10px;
    }

    .history-list {
      display: grid;
      gap: 10px;
    }

    .history-item {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(255, 255, 255, 0.03);
      display: grid;
      gap: 8px;
    }

    .history-item.best,
    .queued-update {
      border-color: rgba(255, 188, 92, 0.5);
      background: linear-gradient(180deg, rgba(255, 188, 92, 0.12), rgba(255, 255, 255, 0.03));
    }

    .history-head,
    .section-head {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .badge-row,
    .param-pills,
    .action-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .history-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 4px;
    }

    button.variant-pick {
      padding: 6px 10px;
      font-size: 11px;
      min-height: 28px;
    }

    .badge {
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 11px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      border: 1px solid var(--line);
      color: var(--muted);
      background: rgba(255, 255, 255, 0.04);
    }

    .badge.best {
      color: #fff3d6;
      border-color: rgba(255, 188, 92, 0.5);
      background: rgba(255, 188, 92, 0.16);
    }

    .badge.queued {
      color: #dff7ee;
      border-color: rgba(92, 200, 161, 0.4);
      background: rgba(92, 200, 161, 0.12);
    }

    .badge.adaptive {
      color: #dff2ff;
      border-color: rgba(126, 192, 255, 0.7);
      background: rgba(70, 140, 255, 0.28);
    }

    .badge.standard {
      color: #e9f7e6;
      border-color: rgba(92, 200, 161, 0.58);
      background: rgba(92, 200, 161, 0.2);
    }

    .param-pill {
      font-family: var(--font-display);
      font-size: 12px;
      padding: 6px 10px;
    }

    .mono {
      font-family: var(--font-display);
    }

    .param-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .param-table th,
    .param-table td {
      text-align: left;
      border-top: 1px solid var(--line);
      padding: 10px 8px;
    }

    .param-table th {
      color: var(--muted);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .manual-input {
      width: 100%;
      max-width: 220px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      padding: 10px 12px;
      font-family: var(--font-display);
    }

    .progress-stack {
      display: grid;
      gap: 14px;
    }

    .cpu-panel {
      display: grid;
      gap: 12px;
    }

    .cpu-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(86px, 1fr));
      gap: 10px;
    }

    .core-card {
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 10px;
      background: rgba(255, 255, 255, 0.03);
      text-align: center;
    }

    .core-label {
      color: var(--muted);
      font-size: 11px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 6px;
    }

    .core-value {
      font-family: var(--font-display);
      font-size: 22px;
    }

    .core-meter {
      height: 8px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.04);
      margin-top: 10px;
    }

    .core-meter-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(92, 200, 161, 0.85), rgba(255, 188, 92, 0.95), rgba(255, 111, 111, 0.95));
    }

    .progress-head {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .progress-label {
      font-weight: 600;
    }

    .progress-track {
      height: 18px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid var(--line);
      background: rgba(255, 255, 255, 0.04);
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(92, 200, 161, 0.85), rgba(255, 188, 92, 0.95));
      transition: width 280ms ease;
    }

    .progress-fill.current {
      background: linear-gradient(90deg, rgba(92, 200, 161, 0.85), rgba(92, 200, 161, 0.45));
    }

    .progress-meta {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 12px;
      margin-top: 8px;
    }

    .status-line {
      min-height: 18px;
      color: var(--muted);
      font-size: 13px;
    }

    .positive { color: var(--accent); }
    .negative { color: var(--danger); }
    .warning { color: var(--accent-warm); }

    .empty {
      color: var(--muted);
      border: 1px dashed var(--line);
      border-radius: 16px;
      padding: 18px;
      text-align: center;
    }

    @media (max-width: 1200px) {
      .summary-grid,
      .layout.primary,
      .layout.secondary,
      .control-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 720px) {
      .app {
        width: min(100vw - 20px, 100%);
        margin: 10px auto 24px;
      }

      .hero,
      .panel {
        padding: 14px;
      }

      .param-table {
        display: block;
        overflow-x: auto;
      }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="hero">
      <div class="hero-top">
        <div>
          <p class="eyebrow">Watcher Optimization Control</p>
          <h1>Backtester</h1>
        </div>
        <div class="hero-meta">
          <a class="link-button" href="/">Watcher</a>
          <span class="pill" id="sessionPill">Session: --</span>
          <span class="pill" id="modePill">Mode: --</span>
          <span class="pill" id="statusPill">Status: idle</span>
        </div>
      </div>

      <div class="summary-grid" id="summaryGrid"></div>

      <div class="actions">
        <button class="primary" id="startButton">Start Backtest</button>
        <button class="danger" id="stopButton">Stop</button>
      </div>
      <div class="option-sub">Po zakończeniu backtestu plik <code>tracked_configs.json</code> jest automatycznie nadpisywany najlepszymi wynikami historii, a dodatkowo możesz ręcznie kolejkować wybrane warianty i nadpisać je przyciskiem <code>Update Tracked-Configs</code>.</div>
      <div class="status-line" id="actionStatus"></div>
    </section>

    <div class="layout primary">
      <div class="stack">
        <section class="panel">
          <h2>Parametry Testu</h2>
          <div class="control-grid">
            <div class="metric-card">
              <div class="metric-label">Zakres danych</div>
              <div class="toggle-group" id="scopeGroup"></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Tryb testowania</div>
              <div class="toggle-group" id="modeGroup"></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Adaptive Grid</div>
              <div id="adaptiveToggle"></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Plan testów</div>
              <div class="pill-row" id="planMeta"></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Sesja do backtestu</div>
              <div id="sessionSelector"></div>
            </div>
          </div>
        </section>

        <section class="panel">
          <div class="panel-head">
            <h2>Rynki</h2>
            <button id="selectAllMarkets">Zaznacz wszystko</button>
          </div>
          <div id="marketsList" class="checkbox-grid"></div>
        </section>

        <section class="panel">
          <div class="panel-head">
            <h2>Strategie</h2>
            <button id="selectAllStrategies">Zaznacz wszystko</button>
          </div>
          <div id="strategiesList" class="checkbox-grid"></div>
        </section>
      </div>

      <div class="stack">
        <section class="panel">
          <h2>Postęp Backtestu</h2>
          <div class="progress-stack">
            <div class="progress-card">
              <div class="progress-head">
                <div class="progress-label" id="currentProgressLabel">Bieżący test</div>
                <div class="muted" id="currentProgressPct">0%</div>
              </div>
              <div class="progress-track"><div class="progress-fill current" id="currentProgressFill"></div></div>
              <div class="progress-meta" id="currentProgressMeta"></div>
            </div>

            <div class="progress-card">
              <div class="progress-head">
                <div class="progress-label" id="totalProgressLabel">Łączny przebieg</div>
                <div class="muted" id="totalProgressPct">0%</div>
              </div>
              <div class="progress-track"><div class="progress-fill" id="totalProgressFill"></div></div>
              <div class="progress-meta" id="totalProgressMeta"></div>
            </div>

            <div class="progress-card cpu-panel">
              <div class="progress-head">
                <div class="progress-label">Obciążenie procesora</div>
                <div class="muted" id="cpuOverall">--</div>
              </div>
              <div class="progress-meta" id="cpuMeta"></div>
              <div class="cpu-grid" id="cpuGrid"></div>
            </div>
          </div>
        </section>

        <section class="panel">
          <h2>Wynik Ostatniego Testu</h2>
          <div id="lastRunBest"></div>
        </section>
      </div>
    </div>

    <div class="layout secondary">
      <section class="panel">
        <div class="panel-head">
          <div>
            <h2>Siatka i Monte Carlo</h2>
            <div class="option-sub" id="trackedQueueMeta">Brak oczekujących zmian do tracked configs.</div>
          </div>
          <button id="updateTrackedConfigsButton">Update Tracked-Configs</button>
        </div>
        <div id="comboList" class="combo-list"></div>
      </section>

      <section class="panel">
        <h2>Aktualne / Ostatnie Wyniki</h2>
        <div id="liveResults" class="result-list"></div>
      </section>
    </div>
  </main>

  <script>
    const appState = {
      scope: "latest_session",
      mode: "full",
      adaptive: false,
      selectedSessionId: "",
      selectedMarkets: [],
      selectedStrategies: [],
      manualSamples: {},
      catalog: null,
      status: null,
      detailsCache: {},
      expandedCombos: new Set(),
      expandedLastRun: new Set(),
      pollHandle: null,
    };

    function detectApiBase() {
      const params = new URLSearchParams(window.location.search);
      const apiParam = params.get("api");
      if (apiParam) return apiParam.replace(/\/$/, "");
      if (window.location.protocol === "file:") {
        const port = params.get("port") || "8000";
        return `http://127.0.0.1:${port}`;
      }
      return window.location.origin.replace(/\/$/, "");
    }

    const API_BASE = detectApiBase();

    function money(value) {
      const sign = value > 0 ? "+" : "";
      return `${sign}$${Number(value || 0).toFixed(2)}`;
    }

    function pct(value) {
      const sign = value > 0 ? "+" : "";
      return `${sign}${Number(value || 0).toFixed(2)}%`;
    }

    function number(value) {
      return Number(value || 0).toLocaleString("pl-PL");
    }

    function colorClass(value) {
      if (value > 0) return "positive";
      if (value < 0) return "negative";
      return "warning";
    }

    function escapeHtml(value) {
      return String(value ?? "")
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#39;");
    }

    function formatTimestamp(value) {
      if (!value) return "--";
      return String(value).replace("T", " ").replace("Z", "").split(".")[0];
    }

    function comboKey(marketKey, strategyKey) {
      return `${marketKey}|${strategyKey}`;
    }

    function trackedUpdates() {
      return appState.status?.tracked_updates || appState.catalog?.status?.tracked_updates || { count: 0, combo_keys: [], items: {} };
    }

    function isQueued(combo) {
      return trackedUpdates().combo_keys?.includes(combo);
    }

    function renderTestModeBadge(enabled) {
      return enabled
        ? '<span class="badge adaptive">adaptive-grid</span>'
        : '<span class="badge standard">standard-grid</span>';
    }

    function resolveComboBadgeMode(item) {
      const details = appState.detailsCache?.[item.combo_key];
      if (details?.queued_update?.selected_variant) {
        return Boolean(details.queued_update.selected_variant.adaptive);
      }
      if (details?.best_variant) {
        return Boolean(details.best_variant.adaptive);
      }
      return Boolean(item.adaptive);
    }

    function resolveLastRunBadgeMode(item) {
      const details = appState.detailsCache?.[item.combo_key];
      if (details?.top_history?.length) {
        return Boolean(details.top_history[0].adaptive);
      }
      if (details?.best_variant) {
        return Boolean(details.best_variant.adaptive);
      }
      return Boolean(item.adaptive ?? appState.status?.results?.last_run?.adaptive);
    }

    function formatParams(parameters = {}) {
      const entries = Object.entries(parameters || {});
      if (!entries.length) {
        return '<span class="option-sub">Brak parametrów.</span>';
      }
      return `
        <div class="param-pills">
          ${entries.map(([key, value]) => `<span class="badge param-pill">${escapeHtml(key)}=${escapeHtml(value)}</span>`).join("")}
        </div>
      `;
    }

    function variantSignature(item) {
      return JSON.stringify({
        timestamp: item?.timestamp || "",
        parameters: item?.parameters || {},
      });
    }

    function isQueuedVariant(details, item) {
      return variantSignature(details?.queued_update?.selected_variant) === variantSignature(item);
    }

    function renderVariantList(items, emptyMessage, options = {}) {
      if (!items?.length) {
        return `<div class="empty">${emptyMessage}</div>`;
      }
      const { details = null, selectable = false } = options;
      return `
        <div class="history-list">
          ${items.map((item, index) => `
            <div class="history-item ${item.is_best ? "best" : ""}">
              <div class="history-head">
                <div>
                  <div class="combo-title">${escapeHtml(item.market_label)} · ${escapeHtml(item.strategy_label)}</div>
                  <div class="badge-row" style="margin-top:8px;">${renderTestModeBadge(item.adaptive)}</div>
                </div>
                <div class="badge-row">
                  ${item.rank ? `<span class="badge ${item.rank === 1 ? "best" : ""}">#${item.rank}</span>` : ""}
                  ${item.is_best ? '<span class="badge best">Najlepsza</span>' : ""}
                </div>
              </div>
              <div class="combo-kpis">
                <span class="${colorClass(item.pnl_usd)}">${money(item.pnl_usd)} / ${pct(item.pnl_percent)}</span>
                <span>WR ${Number(item.win_rate || 0).toFixed(1)}%</span>
                <span>T ${number(item.trades_count || 0)}</span>
                <span>${formatTimestamp(item.timestamp)}</span>
              </div>
              ${formatParams(item.parameters)}
              ${selectable ? `
                <div class="history-actions">
                  <button
                    class="variant-pick ${isQueuedVariant(details, item) ? "attention" : ""}"
                    data-queue-variant-market="${escapeHtml(details.market_key)}"
                    data-queue-variant-strategy="${escapeHtml(details.strategy_key)}"
                    data-queue-variant-index="${index}"
                  >
                    Wybierz ten wariant
                  </button>
                </div>
              ` : ""}
            </div>
          `).join("")}
        </div>
      `;
    }

    function renderTrackedPreview(details) {
      if (!details?.queued_update) {
        return "";
      }
      const queued = details.queued_update;
      return `
        <div class="preview-block">
          <div class="section-head">
            <div class="metric-label">Oczekuje w kolejce tracked configs</div>
            <span class="badge queued">Queued</span>
          </div>
          <div class="option-sub">Zapis docelowy: <span class="mono">${escapeHtml(details.tracked_configs_path || "")}</span></div>
          ${formatParams(queued.config_payload || {})}
        </div>
      `;
    }

    function renderStrategyDetails(details, context) {
      if (!details) {
        return '<div class="empty">Rozwiń kafelek, aby wczytać dane historyczne.</div>';
      }
      if (details.loading) {
        return '<div class="empty">Ładowanie historii strategii...</div>';
      }
      if (details.error) {
        return `<div class="empty">${escapeHtml(details.error)}</div>`;
      }
      if (context === "last-run") {
        return `
          <div class="history-block">
            <div class="section-head">
              <div class="metric-label">5 najlepszych historycznie wariantów dla tego testu</div>
              <div class="option-sub">Najlepszy wariant jest wyróżniony.</div>
            </div>
            ${renderVariantList(details.top_history, "Brak historycznych wariantów dla tego testu.")}
          </div>
          ${renderTrackedPreview(details)}
        `;
      }
      return `
        <div class="history-block">
          <div class="section-head">
            <div class="metric-label">10 ostatnich zapisanych wariantów strategii</div>
            <div class="option-sub">Możesz ręcznie wskazać dowolny wariant z listy i oznaczyć go do nadpisania tracked configs.</div>
          </div>
          ${renderVariantList(details.recent_variants, "Brak zapisanych wariantów tej strategii w historii.", { details, selectable: details.supports_tracked_config })}
        </div>
        <div class="option-sub">${details.tracked_configs_path ? `Docelowy zapis: <span class="mono">${escapeHtml(details.tracked_configs_path)}</span>` : ""}</div>
        ${renderTrackedPreview(details)}
      `;
    }

    function setStatus(message, tone = "muted") {
      const root = document.getElementById("actionStatus");
      root.className = `status-line ${tone}`;
      root.textContent = message;
    }

    async function fetchJson(path, options = {}) {
      const response = await fetch(`${API_BASE}${path}`, options);
      const payload = await response.json();
      if (!response.ok) {
        throw new Error(payload.detail || "Request failed");
      }
      return payload;
    }

    async function ensureStrategyDetails(marketKey, strategyKey) {
      const key = comboKey(marketKey, strategyKey);
      const cached = appState.detailsCache[key];
      if (cached?.loading || cached?.loaded) {
        return cached;
      }
      appState.detailsCache[key] = { loading: true };
      renderLastRun();
      renderCombinations();
      try {
        const payload = await fetchJson(`/api/backtester/strategy-details?market_key=${encodeURIComponent(marketKey)}&strategy_key=${encodeURIComponent(strategyKey)}`);
        appState.detailsCache[key] = { loaded: true, ...payload };
      } catch (error) {
        appState.detailsCache[key] = { error: error.message };
      }
      renderLastRun();
      renderCombinations();
      return appState.detailsCache[key];
    }

    async function queueTrackedConfig(marketKey, strategyKey, selectedVariant = null) {
      try {
        const payload = await fetchJson("/api/backtester/tracked-configs/queue", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ market_key: marketKey, strategy_key: strategyKey, selected_variant: selectedVariant }),
        });
        appState.status = {
          ...(appState.status || {}),
          tracked_updates: payload.tracked_updates,
        };
        const key = comboKey(marketKey, strategyKey);
        if (appState.detailsCache[key]) {
          appState.detailsCache[key] = {
            ...appState.detailsCache[key],
            queued_update: payload.queued,
          };
        }
        setStatus(`Dodano ${marketKey} / ${strategyKey} do kolejki tracked configs.`, "positive");
        renderStatus();
        renderCatalog();
      } catch (error) {
        setStatus(error.message, "negative");
      }
    }

    async function applyTrackedConfigUpdates() {
      try {
        const payload = await fetchJson("/api/backtester/tracked-configs/apply", { method: "POST" });
        appState.status = {
          ...(appState.status || {}),
          tracked_updates: payload.tracked_updates,
        };
        appState.detailsCache = {};
        setStatus(
          payload.applied_count
            ? `Zapisano ${payload.applied_count} zmian do ${payload.tracked_configs_path}.`
            : "Brak oczekujących zmian do zapisania.",
          payload.applied_count ? "positive" : "warning"
        );
        renderStatus();
        renderCatalog();
      } catch (error) {
        setStatus(error.message, "negative");
      }
    }

    function buildQuery() {
      const params = new URLSearchParams();
      params.set("scope", appState.scope);
      params.set("mode", appState.mode);
      params.set("adaptive", String(appState.adaptive));
      params.set("session_id", appState.selectedSessionId || "");
      params.set("markets", appState.selectedMarkets.join(","));
      params.set("strategies", appState.selectedStrategies.join(","));
      params.set("manual_samples", JSON.stringify(appState.manualSamples));
      return params.toString();
    }

    async function refreshCatalog() {
      const payload = await fetchJson(`/api/backtester/catalog?${buildQuery()}`);
      appState.catalog = payload;
      appState.adaptive = Boolean(payload.adaptive);
      appState.selectedSessionId = payload.session_id || appState.selectedSessionId || "";
      appState.status = payload.status;
      renderCatalog();
      renderStatus();
    }

    async function refreshStatus() {
      const payload = await fetchJson("/api/backtester/status");
      appState.status = payload;
      renderStatus();
    }

    async function startBacktest() {
      try {
        const payload = await fetchJson("/api/backtester/start", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            scope: appState.scope,
            mode: appState.mode,
            adaptive: appState.adaptive,
            session_id: appState.selectedSessionId || appState.catalog?.session_id || "",
            selected_markets: appState.selectedMarkets,
            selected_strategies: appState.selectedStrategies,
            manual_samples: appState.manualSamples,
          }),
        });
        appState.status = payload;
        setStatus("Backtester wystartował.", "positive");
        renderStatus();
      } catch (error) {
        setStatus(error.message, "negative");
      }
    }

    async function stopBacktest() {
      try {
        const payload = await fetchJson("/api/backtester/stop", { method: "POST" });
        appState.status = payload;
        setStatus("Backtester został zatrzymany.", "warning");
        renderStatus();
      } catch (error) {
        setStatus(error.message, "negative");
      }
    }

    function renderScopeControls() {
      const root = document.getElementById("scopeGroup");
      const options = [
        { value: "latest_session", label: "Ostatnia sesja" },
        { value: "all", label: "Cała baza" },
      ];
      root.innerHTML = options.map((option) => `
        <label class="chip ${appState.scope === option.value ? "active" : ""}">
          <input type="radio" name="scope" value="${option.value}" ${appState.scope === option.value ? "checked" : ""} />
          ${option.label}
        </label>
      `).join("");
      root.querySelectorAll('input[name="scope"]').forEach((input) => {
        input.addEventListener("change", async (event) => {
          appState.scope = event.target.value;
          appState.selectedMarkets = [];
          await refreshCatalog();
        });
      });
    }

    function renderModeControls() {
      const root = document.getElementById("modeGroup");
      const options = [
        { value: "full", label: "Full" },
        { value: "quick", label: "Quick" },
        { value: "fast-track", label: "Fast-track" },
      ];
      root.innerHTML = options.map((option) => `
        <label class="chip ${appState.mode === option.value ? "active" : ""}">
          <input type="radio" name="mode" value="${option.value}" ${appState.mode === option.value ? "checked" : ""} />
          ${option.label}
        </label>
      `).join("");
      root.querySelectorAll('input[name="mode"]').forEach((input) => {
        input.addEventListener("change", async (event) => {
          appState.mode = event.target.value;
          if (appState.mode === "fast-track") {
            appState.adaptive = false;
          }
          await refreshCatalog();
        });
      });
    }

    function renderAdaptiveControl() {
      const root = document.getElementById("adaptiveToggle");
      const disabled = appState.mode === "fast-track";
      if (disabled && appState.adaptive) {
        appState.adaptive = false;
      }
      root.innerHTML = `
        <div class="checkbox-item">
          <label class="option">
            <input type="checkbox" id="adaptiveInput" ${appState.adaptive ? "checked" : ""} ${disabled ? "disabled" : ""} />
            <div>
              <div class="option-title">Włącz adaptive-grid</div>
              <div class="option-sub">${disabled ? "Adaptive jest niedostępny w fast-track." : "Etapowe zawężanie parametrów: 10% -> 5% -> 1%."}</div>
            </div>
          </label>
        </div>
      `;
      root.querySelector("#adaptiveInput")?.addEventListener("change", async (event) => {
        appState.adaptive = Boolean(event.target.checked);
        await refreshCatalog();
      });
    }

    function renderSessionSelector() {
      const root = document.getElementById("sessionSelector");
      const sessions = appState.catalog?.available_sessions || [];
      if (appState.scope === "all") {
        root.innerHTML = '<div class="option-sub">Tryb pełnej historii nie używa pojedynczej sesji.</div>';
        return;
      }
      if (!sessions.length) {
        root.innerHTML = '<div class="option-sub">Brak zapisanych sesji w bazie.</div>';
        return;
      }
      const effectiveSession = appState.selectedSessionId || appState.catalog?.session_id || sessions[0]?.session_id || "";
      root.innerHTML = `
        <select id="sessionSelect" class="manual-input">
          ${sessions.map((session) => `
            <option value="${session.session_id}" ${effectiveSession === session.session_id ? "selected" : ""}>
              ${escapeHtml(session.label)} · ticki ${number(session.ticks_count)} · rynki ${number(session.market_count)}
            </option>
          `).join("")}
        </select>
      `;
      root.querySelector("#sessionSelect")?.addEventListener("change", async (event) => {
        appState.selectedSessionId = event.target.value;
        appState.selectedMarkets = [];
        appState.detailsCache = {};
        await refreshCatalog();
      });
    }

    function renderMarkets() {
      const root = document.getElementById("marketsList");
      const markets = appState.catalog?.available_markets || [];
      if (!markets.length) {
        root.innerHTML = '<div class="empty">Brak rynków w bazie danych.</div>';
        return;
      }
      root.innerHTML = markets.map((market) => `
        <div class="checkbox-item">
          <label class="option">
            <input type="checkbox" data-market="${market.market_key}" ${appState.selectedMarkets.includes(market.market_key) ? "checked" : ""} />
            <div>
              <div class="option-title">${market.label}</div>
              <div class="option-sub">${number(market.ticks_count)} ticków · ${number(market.market_instances)} rynków w próbce</div>
            </div>
          </label>
        </div>
      `).join("");
      root.querySelectorAll("[data-market]").forEach((input) => {
        input.addEventListener("change", async (event) => {
          const value = event.target.dataset.market;
          if (event.target.checked) {
            appState.selectedMarkets = [...new Set([...appState.selectedMarkets, value])];
          } else {
            appState.selectedMarkets = appState.selectedMarkets.filter((item) => item !== value);
          }
          await refreshCatalog();
        });
      });
    }

    function renderStrategies() {
      const root = document.getElementById("strategiesList");
      const strategies = appState.catalog?.available_strategies || [];
      root.innerHTML = strategies.map((strategy) => `
        <div class="checkbox-item">
          <label class="option">
            <input type="checkbox" data-strategy="${strategy.strategy_key}" ${appState.selectedStrategies.includes(strategy.strategy_key) ? "checked" : ""} />
            <div>
              <div class="option-title">${strategy.strategy_label}</div>
              <div class="option-sub">${strategy.summary}</div>
            </div>
          </label>
        </div>
      `).join("");
      root.querySelectorAll("[data-strategy]").forEach((input) => {
        input.addEventListener("change", async (event) => {
          const value = event.target.dataset.strategy;
          if (event.target.checked) {
            appState.selectedStrategies = [...new Set([...appState.selectedStrategies, value])];
          } else {
            appState.selectedStrategies = appState.selectedStrategies.filter((item) => item !== value);
          }
          await refreshCatalog();
        });
      });
    }

    function renderSummary() {
      const summary = appState.catalog?.summary || { total_tests: 0, total_grid_points: 0, total_estimated_operations: 0 };
      const status = appState.status || {};
      const grid = document.getElementById("summaryGrid");
      grid.innerHTML = `
        <div class="summary-card">
          <div class="label">Łączna liczba testów</div>
          <div class="value">${number(summary.total_tests)}</div>
        </div>
        <div class="summary-card">
          <div class="label">Punkty siatki / Monte Carlo</div>
          <div class="value">${number(summary.total_grid_points)}</div>
        </div>
        <div class="summary-card">
          <div class="label">Koszt operacji</div>
          <div class="value">${number(summary.total_estimated_operations)}</div>
        </div>
        <div class="summary-card">
          <div class="label">Czas ostatniego przebiegu</div>
          <div class="value">${status.results?.last_run?.elapsed_label || "--"}</div>
        </div>
      `;
    }

    function renderPlanMeta() {
      const summary = appState.catalog?.summary || {};
      const root = document.getElementById("planMeta");
      root.innerHTML = `
        <span class="pill">Testów: ${number(summary.total_tests || 0)}</span>
        <span class="pill">Punktów: ${number(summary.total_grid_points || 0)}</span>
        <span class="pill">Koszt: ${number(summary.total_estimated_operations || 0)}</span>
      `;
    }

    function renderCombinations() {
      const root = document.getElementById("comboList");
      const details = appState.catalog?.combination_details || [];
      if (!details.length) {
        root.innerHTML = '<div class="empty">Wybierz co najmniej jeden rynek i jedną strategię.</div>';
        return;
      }
      root.innerHTML = details.map((item) => `
        <details class="combo-card ${isQueued(item.combo_key) ? "queued-update" : ""}" data-combo-card="${item.combo_key}" data-market-key="${item.market_key}" data-strategy-key="${item.strategy_key}" ${appState.expandedCombos.has(item.combo_key) ? "open" : ""}>
          <summary>
            <div class="combo-top">
              <div>
                <div class="combo-title">${item.market_label} · ${item.strategy_label}</div>
                <div class="option-sub">${item.summary}</div>
                <div class="badge-row" style="margin-top:8px;">${renderTestModeBadge(resolveComboBadgeMode(item))}</div>
              </div>
              <div class="combo-kpis">
                <span>siatka: ${number(item.raw_total_combinations)}</span>
                <span>próbki: ${number(item.effective_sample_count)}</span>
                <span>ticki: ${number(item.ticks_count)}</span>
                <span>koszt: ${number(item.estimated_operations)}</span>
              </div>
            </div>
          </summary>
          <div class="combo-body">
            <div class="option-sub">${item.sampling_note}</div>
            <div>
              <div class="metric-label">Ręczne próbkowanie Monte Carlo</div>
              <input class="manual-input" type="number" min="1" step="1" value="${item.manual_sample_override || ""}" data-sample="${item.combo_key}" placeholder="${item.adaptive ? "adaptive" : "auto"}" ${item.adaptive ? "disabled" : ""} />
            </div>
            <table class="param-table">
              <thead>
                <tr>
                  <th>Parametr / trigger</th>
                  <th>Zakres min</th>
                  <th>Zakres max</th>
                  <th>Skok</th>
                  <th>Liczba wariantów</th>
                </tr>
              </thead>
              <tbody>
                ${item.parameters.map((param) => `
                  <tr>
                    <td>${param.name}</td>
                    <td>${param.min}</td>
                    <td>${param.max}</td>
                    <td>${param.step ?? "--"}</td>
                    <td>${number(param.variants)}</td>
                  </tr>
                `).join("")}
              </tbody>
            </table>
            ${renderStrategyDetails(appState.detailsCache[item.combo_key], "combo")}
          </div>
        </details>
      `).join("");

      root.querySelectorAll("[data-sample]").forEach((input) => {
        input.addEventListener("change", async (event) => {
          const comboKey = event.target.dataset.sample;
          const value = Number(event.target.value);
          if (!value || value <= 0) {
            delete appState.manualSamples[comboKey];
          } else {
            appState.manualSamples[comboKey] = value;
          }
          await refreshCatalog();
        });
      });

      root.querySelectorAll("[data-combo-card]").forEach((element) => {
        element.addEventListener("toggle", async (event) => {
          const detailsElement = event.currentTarget;
          const key = detailsElement.dataset.comboCard;
          const marketKey = detailsElement.dataset.marketKey;
          const strategyKey = detailsElement.dataset.strategyKey;
          if (detailsElement.open) {
            appState.expandedCombos.add(key);
            await ensureStrategyDetails(marketKey, strategyKey);
          } else {
            appState.expandedCombos.delete(key);
          }
        });
      });

      root.querySelectorAll("[data-queue-variant-market]").forEach((button) => {
        button.addEventListener("click", async (event) => {
          event.preventDefault();
          const marketKey = event.currentTarget.dataset.queueVariantMarket;
          const strategyKey = event.currentTarget.dataset.queueVariantStrategy;
          const variantIndex = Number(event.currentTarget.dataset.queueVariantIndex);
          const key = comboKey(marketKey, strategyKey);
          const selectedVariant = appState.detailsCache[key]?.recent_variants?.[variantIndex];
          await queueTrackedConfig(marketKey, strategyKey, selectedVariant || null);
        });
      });
    }

    function renderProgress() {
      const progress = appState.status?.progress || {};
      const cpu = appState.status?.cpu || {};
      const currentPct = Number(progress.current_test_progress_pct || 0);
      const totalPct = Number(progress.total_progress_pct || 0);
      document.getElementById("currentProgressFill").style.width = `${currentPct}%`;
      document.getElementById("totalProgressFill").style.width = `${totalPct}%`;
      document.getElementById("currentProgressPct").textContent = `${currentPct.toFixed(1)}%`;
      document.getElementById("totalProgressPct").textContent = `${totalPct.toFixed(1)}%`;
      document.getElementById("currentProgressLabel").textContent = progress.current_test_market
        ? `${progress.current_test_market} · ${progress.current_test_strategy}`
        : "Bieżący test";
      document.getElementById("totalProgressLabel").textContent = progress.total_tests
        ? `Test ${progress.current_test_index || 0} z ${progress.total_tests}`
        : "Łączny przebieg";
      document.getElementById("currentProgressMeta").innerHTML = `
        <span>Punkty: ${number(progress.current_test_points_done || 0)} / ${number(progress.current_test_points_total || 0)}</span>
        <span>${progress.current_test_label || "Brak aktywnego testu"}</span>
      `;
      document.getElementById("totalProgressMeta").innerHTML = `
        <span>Koszt: ${number(progress.processed_operations || 0)} / ${number(progress.total_estimated_operations || 0)}</span>
        <span>Start: ${progress.elapsed_label || "00:00"}</span>
        <span>Pozostało: ${progress.eta_label || "--"}</span>
        <span>Szybkość: ${number(progress.operations_per_sec || 0)}/s</span>
      `;
      renderCpu(cpu);
    }

    function renderCpu(cpu) {
      const overall = document.getElementById("cpuOverall");
      const meta = document.getElementById("cpuMeta");
      const grid = document.getElementById("cpuGrid");
      overall.textContent = cpu.available
        ? `Średnio ${Number(cpu.overall_percent || 0).toFixed(1)}%`
        : "Brak danych";
      meta.innerHTML = `
        <span>Rdzeni logicznych: ${number(cpu.logical_cores || 0)}</span>
        <span>Źródło: ${cpu.source || "--"}</span>
        <span>${cpu.note || "Aktualizacja przy każdym odświeżeniu statusu."}</span>
      `;
      const values = Array.isArray(cpu.per_core_percent) ? cpu.per_core_percent : [];
      if (!values.length) {
        grid.innerHTML = '<div class="empty">Metryki CPU chwilowo niedostępne.</div>';
        return;
      }
      grid.innerHTML = values.map((value, index) => {
        const numeric = typeof value === "number";
        const pctValue = numeric ? Math.max(0, Math.min(100, value)) : 0;
        return `
          <div class="core-card">
            <div class="core-label">Core ${index + 1}</div>
            <div class="core-value ${numeric ? '' : 'warning'}">${numeric ? `${pctValue.toFixed(0)}%` : '--'}</div>
            <div class="core-meter">
              <div class="core-meter-fill" style="width:${pctValue}%"></div>
            </div>
          </div>
        `;
      }).join("");
    }

    function renderLastRun() {
      const root = document.getElementById("lastRunBest");
      const items = appState.status?.results?.completed_results || [];
      if (!items.length) {
        const best = appState.status?.results?.best_of_run || appState.status?.results?.last_run?.best_result;
        if (!best) {
          root.innerHTML = '<div class="empty">Brak zakończonego testu do pokazania.</div>';
          return;
        }
        root.innerHTML = `
          <div class="result-card">
            <div class="combo-title">${best.market_label} · ${best.strategy_label}</div>
            <div class="badge-row" style="margin:8px 0 0;">${renderTestModeBadge(best.adaptive || appState.status?.results?.last_run?.adaptive)}</div>
            <div class="combo-kpis">
              <span class="${colorClass(best.pnl_usd)}">${money(best.pnl_usd)} / ${pct(best.pnl_percent)}</span>
              <span>WR ${Number(best.win_rate || 0).toFixed(1)}%</span>
              <span>Transakcje ${number(best.trades_count || 0)}</span>
            </div>
            <div class="option-sub" style="margin-top:10px;">${Object.entries(best.parameters || {}).map(([key, value]) => `${key}=${value}`).join(", ") || "Brak parametrów."}</div>
          </div>
        `;
        return;
      }
      root.innerHTML = items.map((item) => `
        <details class="result-card ${isQueued(item.combo_key) ? "queued-update" : ""}" data-last-run-card="${item.combo_key}" data-market-key="${item.market_key}" data-strategy-key="${item.strategy_key}" ${appState.expandedLastRun.has(item.combo_key) ? "open" : ""}>
          <summary class="result-summary">
            <div class="combo-top">
              <div>
                <div class="combo-title">${item.market_label} · ${item.strategy_label}</div>
                <div class="option-sub">${item.created_at ? `Zapis wyniku: ${formatTimestamp(item.created_at)}` : "Kliknij, aby rozwinąć historię tej strategii."}</div>
                <div class="badge-row" style="margin-top:8px;">${renderTestModeBadge(resolveLastRunBadgeMode(item))}</div>
              </div>
              <div class="combo-kpis">
                <span class="${colorClass(item.pnl_usd)}">${money(item.pnl_usd)} / ${pct(item.pnl_percent)}</span>
                <span>WR ${Number(item.win_rate || 0).toFixed(1)}%</span>
                <span>T ${number(item.trades_count || 0)}</span>
                ${isQueued(item.combo_key) ? '<span class="badge queued">Queued</span>' : ""}
              </div>
            </div>
          </summary>
          <div class="result-body">
            <div class="history-block">
              <div class="metric-label">Parametry zwycięskiego wariantu z ostatniego runu</div>
              ${formatParams(item.parameters)}
            </div>
            ${renderStrategyDetails(appState.detailsCache[item.combo_key], "last-run")}
          </div>
        </details>
      `).join("");

      root.querySelectorAll("[data-last-run-card]").forEach((element) => {
        element.addEventListener("toggle", async (event) => {
          const detailsElement = event.currentTarget;
          const key = detailsElement.dataset.lastRunCard;
          const marketKey = detailsElement.dataset.marketKey;
          const strategyKey = detailsElement.dataset.strategyKey;
          if (detailsElement.open) {
            appState.expandedLastRun.add(key);
            await ensureStrategyDetails(marketKey, strategyKey);
          } else {
            appState.expandedLastRun.delete(key);
          }
        });
      });
    }

    function renderTrackedUpdatesMeta() {
      const pending = trackedUpdates();
      const button = document.getElementById("updateTrackedConfigsButton");
      const meta = document.getElementById("trackedQueueMeta");
      if (!button || !meta) {
        return;
      }
      button.className = pending.count ? "attention" : "";
      button.textContent = pending.count ? `Update Tracked-Configs (${pending.count})` : "Update Tracked-Configs";
      meta.innerHTML = pending.count
        ? `Oczekuje <strong>${pending.count}</strong> zmian do zapisu. Docelowy plik: <span class="mono">${escapeHtml(pending.tracked_configs_path || "")}</span>.`
        : "Brak oczekujących zmian do tracked configs.";
    }

    function renderLiveResults() {
      const root = document.getElementById("liveResults");
      const items = appState.status?.results?.completed_results || [];
      if (!items.length) {
        root.innerHTML = '<div class="empty">Wyniki pojawią się po zakończeniu pierwszych testów.</div>';
        return;
      }
      root.innerHTML = items.map((item) => `
        <div class="result-card">
          <div class="combo-title">${item.market_label} · ${item.strategy_label}</div>
          <div class="combo-kpis">
            <span class="${colorClass(item.pnl_usd)}">${money(item.pnl_usd)} / ${pct(item.pnl_percent)}</span>
            <span>WR ${Number(item.win_rate || 0).toFixed(1)}%</span>
            <span>Próbek ${number(item.sampled_count || 0)}</span>
          </div>
        </div>
      `).join("");
    }

    function renderStatus() {
      const status = appState.status || { status: "idle", progress: {}, results: {} };
      document.getElementById("sessionPill").textContent = `Session: ${appState.catalog?.session_id || "--"}`;
      document.getElementById("modePill").textContent = `Mode: ${appState.catalog?.mode_label || appState.mode}`;
      document.getElementById("statusPill").textContent = `Status: ${status.status || "idle"}`;
      document.getElementById("startButton").disabled = ["starting", "running"].includes(status.status);
      document.getElementById("stopButton").disabled = !["starting", "running"].includes(status.status);
      renderProgress();
      renderLastRun();
      renderLiveResults();
      renderTrackedUpdatesMeta();
    }

    function renderCatalog() {
      renderScopeControls();
      renderModeControls();
      renderAdaptiveControl();
      renderSessionSelector();
      renderMarkets();
      renderStrategies();
      renderSummary();
      renderPlanMeta();
      renderCombinations();
    }

    async function bootstrap() {
      document.getElementById("startButton").addEventListener("click", startBacktest);
      document.getElementById("stopButton").addEventListener("click", stopBacktest);
      document.getElementById("updateTrackedConfigsButton").addEventListener("click", applyTrackedConfigUpdates);
      document.getElementById("selectAllMarkets").addEventListener("click", async () => {
        appState.selectedMarkets = (appState.catalog?.available_markets || []).map((item) => item.market_key);
        await refreshCatalog();
      });
      document.getElementById("selectAllStrategies").addEventListener("click", async () => {
        appState.selectedStrategies = (appState.catalog?.available_strategies || []).map((item) => item.strategy_key);
        await refreshCatalog();
      });

      const initialCatalog = await fetchJson(`/api/backtester/catalog?scope=${appState.scope}&mode=${appState.mode}&adaptive=${appState.adaptive}`);
      appState.catalog = initialCatalog;
      appState.status = initialCatalog.status;
      appState.adaptive = Boolean(initialCatalog.adaptive);
      appState.selectedSessionId = initialCatalog.session_id || "";
      appState.selectedMarkets = initialCatalog.available_markets.map((item) => item.market_key);
      appState.selectedStrategies = initialCatalog.available_strategies.map((item) => item.strategy_key);
      await refreshCatalog();

      if (appState.pollHandle) window.clearInterval(appState.pollHandle);
      appState.pollHandle = window.setInterval(refreshStatus, 1000);
    }

    bootstrap().catch((error) => {
      document.body.innerHTML = `
        <main class="app">
          <section class="panel">
            <h2>Backtester Error</h2>
            <p>${error.message}</p>
            <p class="muted">Uruchom dashboard pod adresem serwera, np. http://127.0.0.1:8000/backtester</p>
          </section>
        </main>
      `;
    });
  </script>
</body>
</html>
